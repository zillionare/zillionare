1
00:00:00.000 --> 00:00:02.000
大家好，让我们来认识一下

2
00:00:02.000 --> 00:00:05.000
Polars 库，我们将比较它

3
00:00:05.000 --> 00:00:08.000
与广受欢迎的熊猫一起。极地是

4
00:00:08.000 --> 00:00:10.000
快速高效的dataf框架库

5
00:00:10.000 --> 00:00:12.000
专为处理大数据而设计

6
00:00:12.000 --> 00:00:14.000
套。它的构建具有以下性能

7
00:00:14.000 --> 00:00:16.000
考虑利用多线程和

8
00:00:16.000 --> 00:00:18.000
并行处理来处理数据

9
00:00:18.000 --> 00:00:21.000
快速操纵任务。极地是

10
00:00:21.000 --> 00:00:23.000
在 Rust 中实现，这使得它能够

11
00:00:23.000 --> 00:00:26.000
与其他产品相比提供卓越的速度

12
00:00:26.000 --> 00:00:28.000
dataf 框架库，如 pandas。这

13
00:00:28.000 --> 00:00:31.000
库支持以下操作

14
00:00:31.000 --> 00:00:32.000
过滤、聚合和

15
00:00:32.000 --> 00:00:34.000
数据的转换。这是

16
00:00:34.000 --> 00:00:36.000
对于数据分析师特别有用

17
00:00:36.000 --> 00:00:39.000
以及需要工作的数据科学家

18
00:00:39.000 --> 00:00:42.000
有效地处理大量数据。

19
00:00:42.000 --> 00:00:45.000
借助 Python 和 RS API，Polars 是

20
00:00:45.000 --> 00:00:47.000
现代数据易于访问且功能强大

21
00:00:47.000 --> 00:00:50.000
处理工作流程。正如我之前所说，

22
00:00:50.000 --> 00:00:52.000
这个库提供了广泛的

23
00:00:52.000 --> 00:00:54.000
数据操作函数，

24
00:00:54.000 --> 00:00:56.000
聚合、转化。但在

25
00:00:56.000 --> 00:00:59.000
我认为，它的主要特点是懒惰

26
00:00:59.000 --> 00:01:02.000
评估。什么是惰性评估？

27
00:01:02.000 --> 00:01:04.000
惰性求值是一种计算方法

28
00:01:04.000 --> 00:01:07.000
延迟执行的策略

29
00:01:07.000 --> 00:01:10.000
操作直到其结果实际上是

30
00:01:10.000 --> 00:01:12.000
需要。在极地背景下，这

31
00:01:12.000 --> 00:01:15.000
意味着数据操纵操作

32
00:01:15.000 --> 00:01:17.000
当他们没有立即执行

33
00:01:17.000 --> 00:01:20.000
被定义。相反，它们被记录下来

34
00:01:20.000 --> 00:01:23.000
作为要执行的一系列步骤

35
00:01:23.000 --> 00:01:25.000
之后。这种方法允许极客

36
00:01:25.000 --> 00:01:27.000
优化整个序列

37
00:01:27.000 --> 00:01:29.000
减少整体运营

38
00:01:29.000 --> 00:01:31.000
计算工作量和改进

39
00:01:31.000 --> 00:01:34.000
仅执行必要的性能

40
00:01:34.000 --> 00:01:36.000
计算在最后。其他

41
00:01:36.000 --> 00:01:39.000
重要的特性是多线程

42
00:01:39.000 --> 00:01:41.000
加工。的主要优势之一

43
00:01:41.000 --> 00:01:44.000
极化其处理数据的能力

44
00:01:44.000 --> 00:01:47.000
同时多个线程。这

45
00:01:47.000 --> 00:01:49.000
意味着不是执行任务

46
00:01:49.000 --> 00:01:52.000
一个接一个地依次排列，极地

47
00:01:52.000 --> 00:01:54.000
可以将工作量分割成更小的工作量

48
00:01:54.000 --> 00:01:57.000
零件并同时运行它们

49
00:01:57.000 --> 00:02:00.000
多个CPU核心。他们显着地

50
00:02:00.000 --> 00:02:03.000
加快数据操作速度，尤其是

51
00:02:03.000 --> 00:02:06.000
处理大型数据集时。极性

52
00:02:06.000 --> 00:02:08.000
建议这种效率，因为它是

53
00:02:08.000 --> 00:02:10.000
使用 Rust（一种编程语言）构建

54
00:02:10.000 --> 00:02:12.000
专为高性能和安全而设计

55
00:02:12.000 --> 00:02:15.000
内存管理。 Rust 让事情变得更容易

56
00:02:15.000 --> 00:02:17.000
使用并行计算，意味着

57
00:02:17.000 --> 00:02:20.000
极地可以充分利用电力

58
00:02:20.000 --> 00:02:22.000
具有多核的现代计算机

59
00:02:22.000 --> 00:02:24.000
处理器。

60
00:02:24.000 --> 00:02:27.000
Polars 的另一个强大功能是

61
00:02:27.000 --> 00:02:29.000
记忆地图数据的能力。这意味着

62
00:02:29.000 --> 00:02:32.000
而不是加载整个大

63
00:02:32.000 --> 00:02:34.000
数据设置到 RAM 中，这可能会减慢速度

64
00:02:34.000 --> 00:02:37.000
您的计算机甚至导致其崩溃，

65
00:02:37.000 --> 00:02:39.000
极化器只能读取和处理

66
00:02:39.000 --> 00:02:41.000
目前需要的零件。为了

67
00:02:41.000 --> 00:02:43.000
例如，如果您正在处理大量

68
00:02:43.000 --> 00:02:47.000
CSV 或停车钥匙文件，Polers 没有

69
00:02:47.000 --> 00:02:49.000
需要将整个文件加载到内存中。

70
00:02:49.000 --> 00:02:52.000
相反，它直接访问数据

71
00:02:52.000 --> 00:02:54.000
根据需要从文件中，使

72
00:02:54.000 --> 00:02:56.000
处理速度更快，内存更多

73
00:02:56.000 --> 00:02:59.000
高效的。这些功能使 Polers 成为

74
00:02:59.000 --> 00:03:00.000
与大公司合作的绝佳选择

75
00:03:00.000 --> 00:03:02.000
数据有助于分析师和

76
00:03:02.000 --> 00:03:04.000
研究人员处理大型数据集

77
00:03:04.000 --> 00:03:06.000
快速有效，无需

78
00:03:06.000 --> 00:03:09.000
需要高端硬件。

79
00:03:09.000 --> 00:03:13.000
Polar 建立在 Apache Arrow 之上，Apache Arrow

80
00:03:13.000 --> 00:03:15.000
数据格式旨在使数据

81
00:03:15.000 --> 00:03:17.000
存储和传输速度更快

82
00:03:17.000 --> 00:03:20.000
高效的。将箭头视为高

83
00:03:20.000 --> 00:03:22.000
优化的组织和结构方式

84
00:03:22.000 --> 00:03:24.000
以便快速处理数据

85
00:03:24.000 --> 00:03:27.000
由不同的系统。因为箭头是

86
00:03:27.000 --> 00:03:29.000
由极地使用，它允许极地

87
00:03:29.000 --> 00:03:32.000
与其他工具无缝共享数据

88
00:03:32.000 --> 00:03:34.000
以及也使用箭头的系统。为了

89
00:03:34.000 --> 00:03:37.000
例如，如果您在极地工作并且

90
00:03:37.000 --> 00:03:39.000
想要将您的数据传递给不同的

91
00:03:39.000 --> 00:03:42.000
系统，例如机器学习工具或

92
00:03:42.000 --> 00:03:44.000
另一个数据分析库，箭头

93
00:03:44.000 --> 00:03:46.000
使数据传输顺利进行

94
00:03:46.000 --> 00:03:48.000
且高效，无需

95
00:03:48.000 --> 00:03:50.000
将数据转换为不同的格式

96
00:03:50.000 --> 00:03:53.000
这可能是缓慢且昂贵的。其他

97
00:03:53.000 --> 00:03:56.000
使 Polars 用户友好的功能，

98
00:03:56.000 --> 00:04:00.000
它是类似 pandas 的 API。熊猫是其中之一

99
00:04:00.000 --> 00:04:02.000
最流行的数据分析工具

100
00:04:02.000 --> 00:04:05.000
Python 和许多数据分析师

101
00:04:05.000 --> 00:04:07.000
科学家们已经熟悉如何

102
00:04:07.000 --> 00:04:09.000
有用。 Polers 的设计初衷是为了感受

103
00:04:09.000 --> 00:04:12.000
pandas 用户很熟悉。所以如果你

104
00:04:12.000 --> 00:04:14.000
已经了解pandas了，你可以开始使用

105
00:04:14.000 --> 00:04:16.000
无需学习的极地

106
00:04:16.000 --> 00:04:19.000
一切从头开始。然而，虽然

107
00:04:19.000 --> 00:04:21.000
API 看起来很熟悉，polar 有

108
00:04:21.000 --> 00:04:23.000
增加了性能优势

109
00:04:23.000 --> 00:04:25.000
更快、更高效，尤其是

110
00:04:25.000 --> 00:04:28.000
当处理大数据集时。所以如果

111
00:04:28.000 --> 00:04:30.000
你来自熊猫，你可以

112
00:04:30.000 --> 00:04:33.000
受益于同样易于使用的语法

113
00:04:33.000 --> 00:04:35.000
但享受速度和记忆力

114
00:04:35.000 --> 00:04:38.000
极性的效率。

115
00:04:38.000 --> 00:04:40.000
尽管极地有许多伟大的

116
00:04:40.000 --> 00:04:42.000
功能有一些限制

117
00:04:42.000 --> 00:04:45.000
考虑。重要的是要记住

118
00:04:45.000 --> 00:04:47.000
就像任何工具一样，它可能不是

119
00:04:47.000 --> 00:04:50.000
最适合各种情况。我们会去

120
00:04:50.000 --> 00:04:52.000
更详细地了解这些缺点

121
00:04:52.000 --> 00:04:55.000
稍后但现在让我们看一下

122
00:04:55.000 --> 00:04:57.000
在一些挑战中。一种潜力

123
00:04:57.000 --> 00:05:00.000
缺点是 Polars 是

124
00:05:00.000 --> 00:05:02.000
与更多相比相对较新

125
00:05:02.000 --> 00:05:05.000
建立了像pandas这样的图书馆。自从

126
00:05:05.000 --> 00:05:07.000
仍在增长，可能会更少

127
00:05:07.000 --> 00:05:10.000
可用的资源，例如教程，

128
00:05:10.000 --> 00:05:12.000
社区支持或文档，

129
00:05:12.000 --> 00:05:14.000
这可能会让初学者变得更加困难

130
00:05:14.000 --> 00:05:18.000
开始吧。另外，由于是新的，

131
00:05:18.000 --> 00:05:20.000
可能有更少的例子来说明如何

132
00:05:20.000 --> 00:05:22.000
公司正在现实世界中使用它

133
00:05:22.000 --> 00:05:25.000
大型项目。因为极地是

134
00:05:25.000 --> 00:05:27.000
尚未广泛采用，有

135
00:05:27.000 --> 00:05:29.000
关于有多少人的信息有限

136
00:05:29.000 --> 00:05:31.000
公司正在生产中使用它

137
00:05:31.000 --> 00:05:33.000
环境。现实世界的系统

138
00:05:33.000 --> 00:05:36.000
公司运营的地方。

139
00:05:36.000 --> 00:05:39.000
大多数使用 Polars 的公司可能不会

140
00:05:39.000 --> 00:05:42.000
公开分享有关它如何适合的详细信息

141
00:05:42.000 --> 00:05:44.000
进入他们的工作流程。所以，更难

142
00:05:44.000 --> 00:05:46.000
知道它在非常情况下的表现如何

143
00:05:46.000 --> 00:05:49.000
大型或复杂的工作负载。然而，

144
00:05:49.000 --> 00:05:51.000
一些公司开始使用

145
00:05:51.000 --> 00:05:53.000
Polars 的数据处理任务

146
00:05:53.000 --> 00:05:56.000
你可能会看到这样的例子

147
00:05:56.000 --> 00:05:59.000
行业。随着图书馆的不断成熟，

148
00:05:59.000 --> 00:06:02.000
它的采用可能会越来越多

149
00:06:02.000 --> 00:06:03.000
公司将开始分享他们的

150
00:06:03.000 --> 00:06:05.000
经验。

151
00:06:05.000 --> 00:06:07.000
那么，让我们开始吧。

152
00:06:07.000 --> 00:06:09.000
现在，我们需要安装该库。

153
00:06:09.000 --> 00:06:12.000
我去现场看看这是命令

154
00:06:12.000 --> 00:06:14.000
安装库。让我们得到

155
00:06:14.000 --> 00:06:17.000
开始了。我将打开我的终端

156
00:06:17.000 --> 00:06:20.000
我已经习惯使用它了。首先，我

157
00:06:20.000 --> 00:06:22.000
将激活我的虚拟环境。如果

158
00:06:22.000 --> 00:06:24.000
你对虚拟不熟悉

159
00:06:24.000 --> 00:06:26.000
环境，强烈推荐

160
00:06:26.000 --> 00:06:28.000
查看我的视频，了解如何管理

161
00:06:28.000 --> 00:06:30.000
虚拟环境及其如何实现

162
00:06:30.000 --> 00:06:33.000
让您的生活更轻松。但如果你不这样做

163
00:06:33.000 --> 00:06:35.000
知道什么是虚拟环境，你

164
00:06:35.000 --> 00:06:37.000
可以直接在里面运行命令

165
00:06:37.000 --> 00:06:40.000
终端。现在，知道如何工作

166
00:06:40.000 --> 00:06:42.000
与虚拟环境不是

167
00:06:42.000 --> 00:06:44.000
优先事项。激活我的后

168
00:06:44.000 --> 00:06:46.000
环境，我可以运行我的 Jupyter

169
00:06:46.000 --> 00:06:49.000
直接从终端通过笔记本

170
00:06:49.000 --> 00:06:52.000
执行命令 Jupyter Notebook。

171
00:06:52.000 --> 00:06:54.000
如果你使用Anaconda，启动后

172
00:06:54.000 --> 00:06:56.000
Jupyter Notebook，你可以安装这个

173
00:06:56.000 --> 00:06:58.000
直接位于木星内部的图书馆

174
00:06:58.000 --> 00:07:01.000
运行以下命令。正如你

175
00:07:01.000 --> 00:07:03.000
可以看到，我已经有了图书馆

176
00:07:03.000 --> 00:07:06.000
安装。那么，我们就可以开始工作了。

177
00:07:06.000 --> 00:07:09.000
首先，我将导入所有必需的

178
00:07:09.000 --> 00:07:12.000
我们将使用的库。

179
00:07:12.000 --> 00:07:14.000
我导入 NumPy 库是因为

180
00:07:14.000 --> 00:07:16.000
我们需要它。对于那些没有的人

181
00:07:16.000 --> 00:07:18.000
熟悉一下，Numpai 很强大

182
00:07:18.000 --> 00:07:20.000
用于数值计算的Python库

183
00:07:20.000 --> 00:07:23.000
计算。在我的个人资料中，您可以找到

184
00:07:23.000 --> 00:07:26.000
关于这个库的教程。

185
00:07:26.000 --> 00:07:31.000
然后我会检查 Polars 的版本。

186
00:07:31.000 --> 00:07:34.000
我已经下载了超过 1 个庞大的数据集

187
00:07:34.000 --> 00:07:38.000
GB 大小。现在我要导入

188
00:07:38.000 --> 00:07:41.000
它使用 Polus 中的读取 CSV 功能。

189
00:07:41.000 --> 00:07:46.000
加载需要一点时间。

190
00:07:46.000 --> 00:07:49.000
然后使用您的形状函数

191
00:07:49.000 --> 00:07:52.000
可能听说过 pandas，我们可以查一下

192
00:07:52.000 --> 00:07:54.000
我们数据集的维度。如果

193
00:07:54.000 --> 00:07:56.000
你不熟悉它的形状

194
00:07:56.000 --> 00:07:59.000
极坐标中的函数返回 tpple

195
00:07:59.000 --> 00:08:00.000
代表行数和

196
00:08:00.000 --> 00:08:03.000
数据框中的列。这个功能

197
00:08:03.000 --> 00:08:05.000
对于快速理解很有用

198
00:08:05.000 --> 00:08:08.000
您的数据集的大小。在这里我们可以

199
00:08:08.000 --> 00:08:11.000
看到数据集包含超过

200
00:08:11.000 --> 00:08:14.000
1.3 亿行。另一个有用的

201
00:08:14.000 --> 00:08:16.000
快速了解函数

202
00:08:16.000 --> 00:08:19.000
不加载所有数据的数据框

203
00:08:19.000 --> 00:08:22.000
是头函数。默认情况下，它

204
00:08:22.000 --> 00:08:25.000
显示前五行。尽我们所能

205
00:08:25.000 --> 00:08:28.000
看，数据框的外观

206
00:08:28.000 --> 00:08:30.000
极地与 略有不同

207
00:08:30.000 --> 00:08:33.000
我们在加载数据时观察到

208
00:08:33.000 --> 00:08:35.000
熊猫。第一个明显的区别

209
00:08:35.000 --> 00:08:38.000
是显示的数据类型信息

210
00:08:38.000 --> 00:08:40.000
对于每一列。

211
00:08:40.000 --> 00:08:43.000
使用极地中的两个 pandas 函数，

212
00:08:43.000 --> 00:08:46.000
我们可以将极坐标数据框转换为

213
00:08:46.000 --> 00:08:48.000
熊猫数据框。这一点特别

214
00:08:48.000 --> 00:08:51.000
当你需要利用 pandas 时很有用

215
00:08:51.000 --> 00:08:54.000
特定功能或与

216
00:08:54.000 --> 00:08:56.000
仅支持 pandas 数据的库

217
00:08:56.000 --> 00:09:00.000
帧。两个 pandas 方法确保

218
00:09:00.000 --> 00:09:01.000
极地之间的平滑过渡

219
00:09:01.000 --> 00:09:04.000
pandas 让您可以利用

220
00:09:04.000 --> 00:09:08.000
两个库都在同一工作流程中。

221
00:09:08.000 --> 00:09:10.000
如果您不想下载大数据

222
00:09:10.000 --> 00:09:12.000
设置到您的计算机上，您可以使用

223
00:09:12.000 --> 00:09:15.000
GitHub 上公开可用的数据集。

224
00:09:15.000 --> 00:09:18.000
为此，请找到一个大型数据集

225
00:09:18.000 --> 00:09:20.000
GitHub。

226
00:09:20.000 --> 00:09:24.000
转到行选项卡并直接复制

227
00:09:24.000 --> 00:09:27.000
关联。

228
00:09:27.000 --> 00:09:30.000
使用Polers中的读取CSV功能

229
00:09:30.000 --> 00:09:33.000
加载它。

230
00:09:33.000 --> 00:09:35.000
和以前一样，需要一点时间

231
00:09:35.000 --> 00:09:37.000
过程，

232
00:09:37.000 --> 00:09:41.000
但最终我们可以看到数据。

233
00:09:41.000 --> 00:09:44.000
对于今天的例子，我们正在与

234
00:09:44.000 --> 00:09:50.000
2022 年芝加哥犯罪数据集。

235
00:09:50.000 --> 00:09:53.000
我们还可以检查列类型和

236
00:09:53.000 --> 00:10:00.000
我们可以看到它包含 2,525,551

237
00:10:00.000 --> 00:10:03.000
行。相当大，但不是太大

238
00:10:03.000 --> 00:10:04.000
压倒。

239
00:10:04.000 --> 00:10:06.000
避免与第一个数据混淆

240
00:10:06.000 --> 00:10:09.000
我们之前加载的框架，我将重命名

241
00:10:09.000 --> 00:10:11.000
这个新的数据框。

242
00:10:11.000 --> 00:10:14.000
我仍然会使用第一个数据框

243
00:10:14.000 --> 00:10:16.000
稍后，但现在我们将与

244
00:10:16.000 --> 00:10:18.000
第二个是从加载的

245
00:10:18.000 --> 00:10:22.000
GitHub。我将重新加载所有单元格

246
00:10:22.000 --> 00:10:25.000
就像熊猫一样。

247
00:10:25.000 --> 00:10:28.000
在极坐标系中，级数是一维的

248
00:10:28.000 --> 00:10:30.000
类似数组的结构，表示

249
00:10:30.000 --> 00:10:33.000
数据框的单列。它可以

250
00:10:33.000 --> 00:10:36.000
包含同类数据类型，例如

251
00:10:36.000 --> 00:10:39.000
整数、浮点数、字符串、布尔值。

252
00:10:39.000 --> 00:10:41.000
系列是数据的构建块

253
00:10:41.000 --> 00:10:43.000
框架和极坐标。他们让我们能够

254
00:10:43.000 --> 00:10:46.000
执行各种数据操作和

255
00:10:46.000 --> 00:10:48.000
过滤等分析操作，

256
00:10:48.000 --> 00:10:51.000
转换、聚合。每个

257
00:10:51.000 --> 00:10:53.000
系列有关联的名称和数据

258
00:10:53.000 --> 00:10:56.000
类型，使其易于在内部引用

259
00:10:56.000 --> 00:10:58.000
数据框。

260
00:10:58.000 --> 00:11:00.000
我们可以从数据中提取一系列

261
00:11:00.000 --> 00:11:03.000
框架有多种方式。第一个

262
00:11:03.000 --> 00:11:06.000
使用列名称。

263
00:11:06.000 --> 00:11:07.000
最直接的方法是

264
00:11:07.000 --> 00:11:10.000
按名称访问列。

265
00:11:10.000 --> 00:11:13.000
为了避免加载整个系列

266
00:11:13.000 --> 00:11:15.000
大数据集，我会使用head

267
00:11:15.000 --> 00:11:18.000
函数只显示前四个

268
00:11:18.000 --> 00:11:20.000
行。

269
00:11:20.000 --> 00:11:23.000
第二个使用 get 列

270
00:11:23.000 --> 00:11:26.000
功能。这种方法有性能

271
00:11:26.000 --> 00:11:28.000
和直接相比的灵活性优势

272
00:11:28.000 --> 00:11:30.000
列访问。对我来说，主要原因是

273
00:11:30.000 --> 00:11:33.000
使用获取列函数是它的错误

274
00:11:33.000 --> 00:11:36.000
处理。如果您尝试检索

275
00:11:36.000 --> 00:11:38.000
不存在的列，Polers 立即

276
00:11:38.000 --> 00:11:41.000
引发错误。这提供了即时

277
00:11:41.000 --> 00:11:43.000
如果有错别字请反馈

278
00:11:43.000 --> 00:11:46.000
列名称。相反，访问

279
00:11:46.000 --> 00:11:48.000
按名称列可以默默地

280
00:11:48.000 --> 00:11:51.000
不返回任何内容或引发关键错误，这

281
00:11:51.000 --> 00:11:54.000
会使调试变得更加困难。

282
00:11:54.000 --> 00:11:58.000
第三种方法是select方法。它

283
00:11:58.000 --> 00:12:01.000
创建一个新的数据框，仅包含

284
00:12:01.000 --> 00:12:03.000
指定的列。然而，即使

285
00:12:03.000 --> 00:12:06.000
它只包含一列，结果

286
00:12:06.000 --> 00:12:08.000
仍然是一个数据框。直接上班

287
00:12:08.000 --> 00:12:11.000
对于一个系列，我们需要将其转换

288
00:12:11.000 --> 00:12:14.000
使用两个系列功能。该选择

289
00:12:14.000 --> 00:12:16.000
Polars 中的方法返回新数据

290
00:12:16.000 --> 00:12:18.000
即使我们只选择一个框架

291
00:12:18.000 --> 00:12:21.000
单列。这意味着如果我

292
00:12:21.000 --> 00:12:25.000
创建 S1 变量并分配它

293
00:12:25.000 --> 00:12:27.000
结果，这不仅仅是一个

294
00:12:27.000 --> 00:12:29.000
列但极坐标数据框

295
00:12:29.000 --> 00:12:33.000
包含一列。所以如果我检查

296
00:12:33.000 --> 00:12:37.000
S1的D型也被我删除到系列中

297
00:12:37.000 --> 00:12:40.000
方法，可能会导致错误，如 D

298
00:12:40.000 --> 00:12:42.000
类型通常是系列的属性

299
00:12:42.000 --> 00:12:45.000
不是数据框。我们在这里

300
00:12:45.000 --> 00:12:48.000
有错误。如果我再次使用两个系列

301
00:12:48.000 --> 00:12:50.000
方法，

302
00:12:50.000 --> 00:12:53.000
S1不再是数据帧而是极坐标

303
00:12:53.000 --> 00:12:55.000
系列和类型属性将

304
00:12:55.000 --> 00:12:58.000
返回分区列的数据类型。

305
00:12:58.000 --> 00:13:00.000
我们把它打印出来吧。

306
00:13:00.000 --> 00:13:03.000
在第一种情况下，我们可以看到打印

307
00:13:03.000 --> 00:13:05.000
当显示的值

308
00:13:05.000 --> 00:13:08.000
地区专栏作为一个系列。在这里我们可以

309
00:13:08.000 --> 00:13:11.000
查看形状、数据类型和

310
00:13:11.000 --> 00:13:14.000
价值观。

311
00:13:14.000 --> 00:13:17.000
第二个案例显示地区

312
00:13:17.000 --> 00:13:19.000
数据框格式内的列

313
00:13:19.000 --> 00:13:22.000
显示列名称及其数据。

314
00:13:22.000 --> 00:13:24.000
现在是时候暂停一下并做一些事情了

315
00:13:24.000 --> 00:13:28.000
一些练习。

316
00:13:28.000 --> 00:13:30.000
在极坐标中，我们可以进行算术运算

317
00:13:30.000 --> 00:13:33.000
使用系列或列的操作

318
00:13:33.000 --> 00:13:36.000
标准Python操作。

319
00:13:36.000 --> 00:13:40.000
例如，我们可以使用加法。如果我们

320
00:13:40.000 --> 00:13:42.000
想要将10添加到一个系列中，我们可以看到

321
00:13:42.000 --> 00:13:45.000
结果系列中的每个数字

322
00:13:45.000 --> 00:13:47.000
与之前相比增加了整整 10

323
00:13:47.000 --> 00:13:50.000
原始系列中的编号。这里

324
00:13:50.000 --> 00:13:53.000
我打印原版系列，我们可以

325
00:13:53.000 --> 00:13:55.000
看到结果。每个值增加

326
00:13:55.000 --> 00:13:57.000
10.

327
00:13:57.000 --> 00:14:00.000
乘法。将一系列乘以

328
00:14:00.000 --> 00:14:04.000
每个值都有两个双倍。这里我比较一下

329
00:14:04.000 --> 00:14:06.000
到原始系列，我们可以看到

330
00:14:06.000 --> 00:14:09.000
每个值都加倍。

331
00:14:09.000 --> 00:14:12.000
减法。减去 20 减少

332
00:14:12.000 --> 00:14:15.000
每个值乘 20。

333
00:14:15.000 --> 00:14:17.000
让我们继续使用聚合方法。
