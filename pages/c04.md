---
theme: ../theme
class: text-center
highlighter: shiki
lineNumbers: true
colorSchema: light
aspectRatio: '12/16'
canvasWidth: 1200
drawings:
  persist: false
transition: slide-left
title: 大富翁. 量化课程答疑
slogan: "The Pilgrim's Progress to Zillionare"
seq: C04
layout: cover
---

# Let's Go Monte Carlo!
## 蒙特卡洛法 资产组合优化

---
---
所谓蒙特卡洛模拟，就是随机产生大量的资产分配方案，然后再计算各种分配方案下，所得到的波动率、夏普率，再根据最优的夏普率，反查资产分配方案。

主要操作我们在上一节已经介绍过，这一步主要做的事情是不断地重复。我们先把代码给出来，再进行解释：

```python

num_ports = 5000

all_weights = np.zeros((num_ports, len(stocks)))
vol_arr = np.zeros(num_ports)
sharpe_arr = np.zeros(num_ports)
port_return_arr = np.zeros((num_ports, len(returns)))
cov_arr = np.zeros(num_ports)

for i in range(num_ports):
    weights = np.array(np.random.random(len(stocks)))
    weights = weights/np.sum(weights)  
                      
    all_weights[i,:] = weights
    
    weighted_returns = weights * returns
    port_return_i = weighted_returns.sum(axis=1)

```
---
---

```python
    port_return_arr[i,:] = port_return_i

    cov = np.cov(port_return_i)

    cov_arr[i] = cov

    # 为避免换行，以下分两行书写
    vol_arr[i] = np.dot(weights.T, np.dot(cov, weights))
    vol_arr[i] = sqrt(vol_arr[i])

    sharpe_arr[i] = sharpe_ratio(port_return_i)
```

我们主要定义了这样四个数组：

1. 权重矩阵 all_weights。我们打算重复5000次采样，由于资产组合共有4个标的，所以，它是一个5000 * 4的矩阵。每一行对应一次资产组合分配。
2. 夏普率数组。它是一个size为5000的数组，记录了每一次计算出来的sharepe率。
3. 波动率数组。它也是一个size为5000的数组，记录了每一次计算邮来的波动率。
4. port_return_arr，在示例中，它是一个 5000 * 241大小的矩阵，每一行记录了组合在过去一年中每一天的收益。

---
---

当上述代码运行完成之后，我们就得到了5000组夏普值。根据夏普值的定义，我们直接找到夏普值最大的那一组，就是风险最小、收益最高的资产组合。

## 最佳投资组合

我们使用np.argmax来寻找夏普最大时的位置，此点即为最佳投资组合：

```python
# 检查最高的sharpe
pos = np.argmax(sharpe_arr)
print(pos, sharpe_arr[pos])
print("stocks", stocks)
print("Portfolio Allocation:", all_weights[pos])
```

这样我们得到资产分配方案类似如下：

|      | 标的1 | 标的2 | 标的3 | 标的4 |
| ---- | ----- | ----- | ----- | ----- |
| 比例 | 35.3% | 0.3%  | 0.8%  | 64%   |

我们将上述试验结果绘制成图形，来看看是否符合有效前沿理论：

---
---

```python
import matplotlib.pyplot as plt

annual_return = np.prod((1 + port_return_arr), axis=1) - 1
plt.scatter(vol_arr, annual_return, c=sharpe_arr, cmap='RdYlBu')
plt.colorbar(label='Sharpe Ratio')

plt.scatter(vol_arr[pos], annual_return[pos], c='red',s=80)
```

我们以波动率为x轴，年化回报为y轴。在每一个x上，都存在若干组年化回报数据，有正有负。显然，对于同一个x，正好是那些处在有

效前沿上的组合，正好是收益最大或者亏损最大的组合。

按照MPT理论，只有那些在y轴上方，且处于有效前沿上的才是值得关注的组合，然后根据我们的风险承受能力，来选择这条线上对应的组合。

我们把夏普率最高的那组方案，用红色的点标注出来。可以看出，它略微偏离了有效前沿，为什么？

---
---


![](https://images.jieyu.ai/images/2023/10/mpt-return-vol.png)

这里的原因是，我们使用了年化收益作为y轴，但这个小红点是用的sharpe最大的点。同一个sharpe率，对应的收益率不只一个，而是一个分布；即使在波动率和sharpe率都确定的情况下，年化收益率也仍然不只一个，仍然是一个分布。关于夏普率与收益率的关系，特别是


与最大回撤的关系，我们在第21课讲过。**这是一个很重要的问题，在投资可能出了状况时，决定着我们要不要暂停量化交易**。

---
---

如果我们把y轴换成sharpe值，则会得到更接近的效前沿理论的一张图：

![](https://images.jieyu.ai/images/2023/10/mpt-sharpe-vol.png)

从走势图来看，我们这样求出来的资产组合确实是最优的。但是，如果我们将它与文章开头的那个图相比，我们会得出什么结论？

**这把牌不行。**

---
---

即使你愿意承担较大风险，这把牌也不能给你想要的收益。**浪得不够狠。你得重新选标的。**

另外，如果你现在就急于用MPT来进行投资。。。你还得再学点啥。

<span style="color:var(--slidev-theme-3rd)">MPT是对过去的总结。历史固然总是在重复自己，一切历史都是当代史。</span> 但是仍然有很多东西要讨论。

首先，我们应该放多少支标的到这个组合里来？我们的示例中只使用了4支，如果我们对沪深300或者中证1000来做指增，会不会更好一点？

其次，如果我们在不同的时间点来优化投资组合，我们得到的仓位显然会有所不同。那么，我们应该**多久计算一次并执行调仓**？会不会有这样一种情况，每次调仓是在用**过去的最优解**，而它**很快就变成了次优或者最劣解**？也就是，这个组合它的**动量周期**是多久？

当然，最重要的是，你必须得知道，<span style="color:var(--slidev-theme-3rd)">这个组合里的标的，他们的故事还能继续讲下去。这是一切的关键。</span>

显然，任何一个有价值的方案，都不是一篇短文能cover的。好，我们先放下这些问题，先来看一个技术问题：

---
---

**执行上述循环5000次，我们花了大约 5.5秒。**

这仅仅是4个标的的组合，也仅仅探索了5000次。随着标的数的增加，我们要搜索的次数需要呈指数级增加，而不是按标的数线性增加。


因此，速度非常重要。没有速度，我们几乎不可能用蒙特卡洛方法来找出最优解。

要提升速度，最直观的方法就是使用所谓的向量化运算。

```python
%%time

all_weights = np.random.rand(num_ports, len(stocks))

shape = (len(all_weights), -1)
all_weights_ = all_weights/all_weights.sum(axis=1)
all_weights = all_weights_.reshape(shape)

# got 241 daily summed returns over 5000 iters
all_port_returns = np.dot(all_weights,returns.T)

# 计算波动率
all_vol = []
all_sharpe = []
```

---
---
```python
for i in range(num_ports):
    vol = np.dot(all_weights[i].T, np.dot(all_cov[i], all_weights[i]))
    all_vol.append(np.sqrt(vol))
    all_sharpe.append(sharpe_ratio(all_port_returns[i]))
    

# 检查最高的sharpe
pos = np.argmax(sharpe_arr)
print(pos, sharpe_arr[pos])
print("stocks", stocks)
print("Portfolio Allocation:", all_weights[pos])
```

在按行计算波动率和夏普率的时候，我不得不做出妥协，改用循环。但即使这样，我们现在的执行时间也只需要0.57秒。<span style="color:var(--slidev-theme-3rd)">提升了大概10倍的速度。</span>

实际上，我们这里的方法几乎肯定不是数学上的最优解。如果每个资产可以从0%到100%进行分配，一共是100种可能性，200支标的的全排列则是100^200次，这是一个非常巨大的搜索空间。所以，在我们的例子中，我们实际上只探索了其中很小的一部分可能性，而就在这部分可能性中，还存在相似的权重--这是一种浪费。

---
---

<span style="color:var(--slidev-theme-3rd)">因此，无论是从性能上考虑、还是要求得最优解上考虑，似乎我们都得寻找更好的方法。这将会在下一篇进行介绍。</span>

## 推荐阅读

* PPZ-C02 CAPM模型及其PYTHON实现
* PPZ-C03 投资组合的Python优化方法
* PPZ-A01 60天搭建量化知识体系之概览
* PPZ-B01-1 如何寻找新的策略/因子
* PPZ-B01-2 量化专业大学都上哪些课
* PPZ-B01-3 做量化必学的金融理论

